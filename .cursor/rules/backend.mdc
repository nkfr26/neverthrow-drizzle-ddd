---
description: 
globs: 
alwaysApply: true
---
# バックエンドコーディングルール

## 使用技術

- NeverThrow
- Drizzle

## 実装パターン

### ディレクトリ構成例

- フレームワークに依存しない
- `packages` 内の `index.ts` はディレクトリ内の関数をまとめて `export` し直す。

```
src
├─ index.ts
├─ db
│  ├─ index.ts
│  └─ schema.ts
└─ packages
   ├─ domain
   │  ├─ branded.ts
   │  ├─ errors.ts
   │  └─ user
   │     ├─ model
   │     │  ├─ index.ts
   │     │  ├─ user-id.ts
   │     │  ├─ user-name.ts
   │     │  └─ user.ts
   │     └─ service
   │        └─ check-user-exists.ts
   ├─ infrastructure
   │  ├─ errors.ts
   │  └─ user
   │     ├─ delete-user-command.ts
   │     ├─ index.ts
   │     ├─ insert-user-command.ts
   │     ├─ select-user-query.ts
   │     └─ update-user-command.ts
   └─ use-case
      └─ user
         ├─ errors.ts
         ├─ register-user.ts
         └─ update-user-name.ts
```

### Branded Types

```typescript
declare const __brand: unique symbol;

export type Branded<Type, Constructor> = Type & {
  readonly [__brand]: Constructor;
};
```

### エラー

```typescript
export class ValidationError extends Error {
  readonly type = "ValidationError";
}
```

### 値オブジェクト

- 不変である
- 交換が可能である
- 等価性によって比較される
- 紐付くふるまいは型定義の下に置く

```typescript
import { type Result, err, ok } from "neverthrow";
import type { Branded } from "../../branded";
import { ValidationError } from "../../errors";

export type UserName = Branded<string, "UserName">;

export const UserName = (value: string): Result<UserName, ValidationError> => {
  if (value.length < 3) {
    return err(new ValidationError("ユーザー名は3文字以上です。"));
  }
  return ok(value as UserName);
};
```

### エンティティ

- オブジェクトの変更は「関数適用による状態遷移」として実装する
- 同じ属性であっても区別される
- 同一性をもつ
- 紐付くふるまいは型定義の下に置く

```typescript
import { Result } from "neverthrow";
import type { ValidationError } from "../../errors";
import { UserId } from "./user-id";
import { UserName } from "./user-name";

export type User = Readonly<{
  id: UserId;
  name: UserName;
}>;

export const User = (
  id: string,
  name: string,
): Result<User, ValidationError> => {
  return Result.combine([UserId(id), UserName(name)]).map(([id, name]) => ({
    id,
    name,
  }));
};

export const changeUserName = (user: User, name: UserName) => ({
  ...user,
  name,
});
```

### コマンド・クエリ

- 永続化
- 再構築
- ただの関数

```typescript
import { eq } from "drizzle-orm";
import { Result, ResultAsync, ok } from "neverthrow";
import { db } from "../../../db";
import { type UserDataModel, usersTable } from "../../../db/schema";
import { User, type UserId, type UserName } from "../../domain/user/model";
import { DbClientError } from "../errors";

const toModel = (from: UserDataModel) => {
  return User(from.userId, from.name);
};

export const selectUserByIdQuery = (id: UserId) => {
  return ResultAsync.fromPromise(
    db.select().from(usersTable).where(eq(usersTable.userId, id)),
    () => new DbClientError(),
  ).andThen((userDataModels) =>
    userDataModels.length ? toModel(userDataModels[0]) : ok(undefined),
  );
};
export type SelectUserByIdQuery = typeof selectUserByIdQuery;

export const selectAllUsersQuery = () => {
  return ResultAsync.fromPromise(
    db.select().from(usersTable),
    () => new DbClientError(),
  ).andThen((userDataModels) => Result.combine(userDataModels.map(toModel)));
};
export type SelectAllUsersQuery = typeof selectAllUsersQuery;

export const selectUserByNameQuery = (name: UserName) => {
  return ResultAsync.fromPromise(
    db.select().from(usersTable).where(eq(usersTable.name, name)),
    () => new DbClientError(),
  ).andThen((userDataModels) =>
    userDataModels.length ? toModel(userDataModels[0]) : ok(undefined),
  );
};
export type SelectUserByNameQuery = typeof selectUserByNameQuery;
```

### ドメインサービス

- 値オブジェクトやエンティティに記述すると不自然なふるまいを定義する
- インフラストラクチャが絡む場合はリポジトリを高階関数としてDIする

```typescript
import type { SelectUserByNameQuery } from "../../../infrastructure/user";
import type { User } from "../model";

export const checkUserExists =
  (selectUserByNameQuery: SelectUserByNameQuery) => (user: User) => {
    return selectUserByNameQuery(user.name).map(
      (duplicateUser) => duplicateUser !== undefined,
    );
  };
export type CheckUserExists = ReturnType<typeof checkUserExists>;
```

### ユースケース

- ドメインオブジェクトを組み合わせて実行する
- リポジトリや部分適用されたドメインサービスを高階関数として使用する順番にDIする

```typescript
import { err } from "neverthrow";
import { v7 as uuidv7 } from "uuid";
import { User } from "../../domain/user/model/user";
import type { CheckUserExists } from "../../domain/user/service/check-user-exists";
import type { InsertUserCommand } from "../../infrastructure/user";
import { CanNotRegisterUserError } from "./errors";

export const registerUser =
  (checkUserExists: CheckUserExists, insertUserCommand: InsertUserCommand) =>
  async (name: string) => {
    // ユーザーの生成
    const userResult = User(uuidv7(), name);
    if (userResult.isErr()) return userResult;

    // ユーザー名の重複確認
    const existsResult = await checkUserExists(userResult.value);
    if (existsResult.isErr()) return existsResult;
    if (existsResult.value)
      return err(new CanNotRegisterUserError("ユーザーは既に存在しています。"));

    // ユーザーの作成
    return await insertUserCommand(userResult.value);
  };
```

```typescript
import { err } from "neverthrow";
import { UserId, UserName } from "../../domain/user/model";
import { changeUserName } from "../../domain/user/model/user";
import type { CheckUserExists } from "../../domain/user/service/check-user-exists";
import type {
  SelectUserByIdQuery,
  UpdateUserCommand,
} from "../../infrastructure/user";
import { CanNotRegisterUserError, UserNotFoundError } from "./errors";

export const updateUserName =
  (
    selectUserByIdQuery: SelectUserByIdQuery,
    checkUserExists: CheckUserExists,
    updateUserCommand: UpdateUserCommand,
  ) =>
  async (id: string, name: string) => {
    // ユーザーIDのバリデーション
    const userIdResult = UserId(id);
    if (userIdResult.isErr()) return userIdResult;

    // ユーザーの存在確認
    const userResult = await selectUserByIdQuery(userIdResult.value);
    if (userResult.isErr()) return userResult;
    const user = userResult.value;
    if (user === undefined)
      return err(new UserNotFoundError("ユーザーが見つかりませんでした。"));

    // ユーザー名のバリデーション
    const userNameResult = UserName(name);
    if (userNameResult.isErr()) return userNameResult;

    // ユーザー名の変更
    const updatedUser = changeUserName(user, userNameResult.value);

    // ユーザー名の重複確認
    const existsResult = await checkUserExists(updatedUser);
    if (existsResult.isErr()) return existsResult;
    if (existsResult.value)
      return err(new CanNotRegisterUserError("ユーザーは既に存在しています。"));

    // ユーザー名の更新
    return await updateUserCommand(updatedUser);
  };
```

### 使用例

```typescript
import { checkUserExists } from "./packages/domain/user/service/check-user-exists";
import {
  insertUserCommand,
  selectUserByNameQuery,
} from "./packages/infrastructure/user";
import { registerUser } from "./packages/use-case/user/register-user";

registerUser(
  checkUserExists(selectUserByNameQuery),
  insertUserCommand,
)("hoge").then((result) => {
  result.match(
    (value) => console.log(value),
    (error) => console.error(error),
  );
});
```

```typescript
import { checkUserExists } from "./packages/domain/user/service/check-user-exists";
import {
  selectUserByIdQuery,
  selectUserByNameQuery,
  updateUserCommand,
} from "./packages/infrastructure/user";
import { updateUserName } from "./packages/use-case/user/update-user-name";

updateUserName(
  selectUserByIdQuery,
  checkUserExists(selectUserByNameQuery),
  updateUserCommand,
)("01966230-8abb-71ca-80f2-0f127a1c4cf0", "fuga").then((result) => {
  result.match(
    (value) => console.log(value),
    (error) => console.error(error),
  );
});
```
