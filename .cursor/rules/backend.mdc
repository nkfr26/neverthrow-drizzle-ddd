---
description: 
globs: 
alwaysApply: true
---
# バックエンドコーディングルール

## 使用技術

- NeverThrow
- Drizzle

## 実装パターン

### ディレクトリ構成例

```
src
├─ db
│  ├─ index.ts
│  └─ schema.ts
└─ packages
   ├─ index.ts
   ├─ domain
   │  ├─ branded.ts
   │  ├─ errors.ts
   │  └─ user
   │     ├─ model
   │     │  ├─ index.ts
   │     │  ├─ user-id.ts
   │     │  ├─ user-name.ts
   │     │  └─ user.ts
   │     └─ service
   │        └─ check-user-exists.ts
   ├─ infrastructure
   │  ├─ errors.ts
   │  └─ user-repository.ts
   └─ use-case
      └─ user
         ├─ errors.ts
         ├─ register-user.ts
         └─ update-user-name.ts
```

### Branded Types

```typescript
declare const __brand: unique symbol;

export type Branded<Type, Constructor> = Type & {
  readonly [__brand]: Constructor;
};
```

### エラー

```typescript
export class ValidationError extends Error {
  readonly type = "ValidationError";
}
```

### 値オブジェクト

- 不変である
- 交換が可能である
- 等価性によって比較される
- 紐付くふるまいは型定義の下に置く

```typescript
import { type Result, err, ok } from "neverthrow";
import type { Branded } from "../../branded";
import { ValidationError } from "../../errors";

export type UserName = Branded<string, "UserName">;

export const UserName = (value: string): Result<UserName, ValidationError> => {
  if (value.length < 3) {
    return err(new ValidationError("ユーザー名は3文字以上です。"));
  }
  return ok(value as UserName);
};
```

### エンティティ

- オブジェクトの変更は「関数適用による状態遷移」として実装する
- 同じ属性であっても区別される
- 同一性をもつ
- 紐付くふるまいは型定義の下に置く

```typescript
import { Result } from "neverthrow";
import type { ValidationError } from "../../errors";
import { UserId } from "./user-id";
import { UserName } from "./user-name";

export type User = Readonly<{
  id: UserId;
  name: UserName;
}>;

export const User = (
  id: string,
  name: string,
): Result<User, ValidationError> => {
  return Result.combine([UserId(id), UserName(name)]).map(([id, name]) => ({
    id,
    name,
  }));
};

export const changeUserName = (user: User, name: UserName) => ({
  ...user,
  name,
});
```

### リポジトリ

- 永続化
- 再構築
- ただの関数

```typescript
import { eq } from "drizzle-orm";
import { ResultAsync, ok } from "neverthrow";
import { db } from "../../db";
import { type UserDataModel, usersTable } from "../../db/schema";
import { User, type UserName } from "../domain/user/model";
import { DbClientError } from "./errors";

const toModel = (from: UserDataModel) => {
  return User(from.userId, from.name);
};

export const findUserByName = (name: UserName) => {
  return ResultAsync.fromPromise(
    db.select().from(usersTable).where(eq(usersTable.name, name)),
    () => new DbClientError(),
  ).andThen((userDataModels) =>
    userDataModels.length ? toModel(userDataModels[0]) : ok(undefined),
  );
};
export type FindUserByName = typeof findUserByName;
```

### ドメインサービス

- 値オブジェクトやエンティティに記述すると不自然なふるまいを定義する
- インフラストラクチャが絡む場合はリポジトリを高階関数としてDIする

```typescript
import type { FindUserByName } from "../../../infrastructure/user-repository";
import type { User } from "../model";

export const checkUserExists =
  (findUserByName: FindUserByName) => (user: User) => {
    return findUserByName(user.name).map(
      (duplicateUser) => duplicateUser !== undefined,
    );
  };
export type CheckUserExists = ReturnType<typeof checkUserExists>;
```

### ユースケース

- ドメインオブジェクトを組み合わせて実行する
- リポジトリや部分適用されたドメインサービスを高階関数として使用する順番にDIする

```typescript
import { err } from "neverthrow";
import { v7 as uuidv7 } from "uuid";
import { User } from "../../domain/user/model/user";
import type { CheckUserExists } from "../../domain/user/service/check-user-exists";
import type { InsertUser } from "../../infrastructure/user-repository";
import { CanNotRegisterUserError } from "./errors";

export const registerUser =
  (checkUserExists: CheckUserExists, insertUser: InsertUser) =>
  async (name: string) => {
    // ユーザーの生成
    const user = User(uuidv7(), name);
    if (user.isErr()) return err(user.error);

    // ユーザー名の重複確認
    const existsResult = await checkUserExists(user.value);
    if (existsResult.isErr()) return err(existsResult.error);
    if (existsResult.value)
      return err(new CanNotRegisterUserError("ユーザーは既に存在しています。"));

    // ユーザーの作成
    return await insertUser(user.value);
  };
```

```typescript
import { err } from "neverthrow";
import { UserId, UserName } from "../../domain/user/model";
import { changeUserName } from "../../domain/user/model/user";
import type { CheckUserExists } from "../../domain/user/service/check-user-exists";
import type {
  FindUserById,
  UpdateUser,
} from "../../infrastructure/user-repository";
import { CanNotRegisterUserError, UserNotFoundError } from "./errors";

export const updateUserName =
  (
    findUserById: FindUserById,
    checkUserExists: CheckUserExists,
    updateUser: UpdateUser,
  ) =>
  async (id: string, name: string) => {
    // ユーザーIDのバリデーション
    const userIdResult = UserId(id);
    if (userIdResult.isErr()) return err(userIdResult.error);

    // ユーザーの存在確認
    const userResult = await findUserById(userIdResult.value);
    if (userResult.isErr()) return err(userResult.error);
    const user = userResult.value;
    if (user === undefined)
      return err(new UserNotFoundError("ユーザーが見つかりませんでした。"));

    // ユーザー名のバリデーション
    const userNameResult = UserName(name);
    if (userNameResult.isErr()) return err(userNameResult.error);

    // ユーザー名の変更
    const updatedUser = changeUserName(user, userNameResult.value);

    // ユーザー名の重複確認
    const existsResult = await checkUserExists(updatedUser);
    if (existsResult.isErr()) return err(existsResult.error);
    if (existsResult.value)
      return err(new CanNotRegisterUserError("ユーザーは既に存在しています。"));

    // ユーザー名の更新
    return await updateUser(updatedUser);
  };
```

### プレゼンテーション

```typescript
import { checkUserExists } from "./domain/user/service/check-user-exists";
import {
  findUserById,
  findUserByName,
  updateUser,
} from "./infrastructure/user-repository";
import { updateUserName } from "./use-case/user/update-user-name";

// registerUser(checkUserExists(findUserByName), insertUser)("hoge");
updateUserName(
  findUserById,
  checkUserExists(findUserByName),
  updateUser,
)("01965e16-5c1e-739b-9c72-3aafe9d05ba4", "fuga").then((result) => {
  result.match(
    (value) => console.log(value),
    (error) => console.error(error),
  );
});
```
