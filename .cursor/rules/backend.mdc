---
description: 
globs: 
alwaysApply: true
---
# バックエンドコーディングルール

## 使用技術

- TypeScript
- NeverThrow
- Drizzle

## 実装パターン

### ディレクトリ構成例

- フレームワークに依存しない
- `packages` 内の `index.ts` はディレクトリ内の関数をまとめて `export` し直す

```
src
├─ index.ts
├─ db
│  ├─ index.ts
│  └─ schema.ts
└─ packages
   ├─ domain
   │  ├─ branded.ts
   │  ├─ errors.ts
   │  └─ user
   │     ├─ model
   │     │  ├─ index.ts
   │     │  ├─ user-id.ts
   │     │  ├─ user-name.ts
   │     │  └─ user.ts
   │     └─ service
   │        └─ user-exists.ts
   ├─ infrastructure
   │  ├─ errors.ts
   │  └─ user
   │     ├─ delete-user-command.ts
   │     ├─ index.ts
   │     ├─ insert-user-command.ts
   │     ├─ select-user-query.ts
   │     └─ update-user-command.ts
   └─ use-case
      └─ user
         ├─ delete-user.ts
         ├─ errors.ts
         ├─ get-all-users.ts
         ├─ register-user.ts
         └─ update-user-name.ts
```

```typescript
export * from "./user";
export * from "./user-id";
export * from "./user-name";
```

### Branded Types

```typescript
declare const __brand: unique symbol;

export type Branded<Type, Constructor> = Type & {
  readonly [__brand]: Constructor;
};
```

### エラー

```typescript
export class ValidationError extends Error {
  readonly type = "ValidationError";
}
```

### 値オブジェクト

- 不変である
- 交換が可能である
- 等価性によって比較される
- 紐付くふるまいは型定義の下に置く

```typescript
import { type Result, err, ok } from "neverthrow";
import type { Branded } from "../../branded";
import { ValidationError } from "../../errors";

export type UserName = Branded<string, "UserName">;

export const UserName = (value: string): Result<UserName, ValidationError> => {
  if (value.length < 3) {
    return err(new ValidationError("ユーザー名は3文字以上です。"));
  }
  return ok(value as UserName);
};
```

### エンティティ

- オブジェクトの変更は「関数適用による状態遷移」として実装する
- 同じ属性であっても区別される
- 同一性をもつ
- 紐付くふるまいは型定義の下に置く

```typescript
import { Result } from "neverthrow";
import type { ValidationError } from "../../errors";
import { UserId } from "./user-id";
import { UserName } from "./user-name";

export type User = Readonly<{
  id: UserId;
  name: UserName;
}>;

export const User = (
  id: string,
  name: string,
): Result<User, ValidationError> => {
  return Result.combine([UserId(id), UserName(name)]).map(([id, name]) => ({
    id,
    name,
  }));
};

export const changeUserName = (user: User, name: UserName) => ({
  ...user,
  name,
});
```

### コマンド・クエリ

- 永続化
- 再構築
- ただの関数

```typescript
import { eq } from "drizzle-orm";
import { ResultAsync } from "neverthrow";
import { db } from "../../../db";
import { usersTable } from "../../../db/schema";
import type { User } from "../../domain/user/model";
import { DbClientError } from "../errors";

export const updateUserCommand = (user: User) => {
  return ResultAsync.fromPromise(
    db
      .update(usersTable)
      .set({ name: user.name })
      .where(eq(usersTable.userId, user.id)),
    (e) => new DbClientError("データベース接続確立エラー", { cause: e }),
  );
};
export type UpdateUserCommand = typeof updateUserCommand;
```

```typescript
import { eq } from "drizzle-orm";
import { Result, ResultAsync, ok } from "neverthrow";
import { db } from "../../../db";
import { type UserDataModel, usersTable } from "../../../db/schema";
import { User, type UserId, type UserName } from "../../domain/user/model";
import { DbClientError } from "../errors";

const toModel = (from: UserDataModel) => {
  return User(from.userId, from.name);
};

export const selectUserByIdQuery = (id: UserId) => {
  return ResultAsync.fromPromise(
    db.select().from(usersTable).where(eq(usersTable.userId, id)),
    (e) => new DbClientError("データベース接続確立エラー", { cause: e }),
  ).andThen((userDataModels) =>
    userDataModels.length ? toModel(userDataModels[0]) : ok(undefined),
  );
};
export type SelectUserByIdQuery = typeof selectUserByIdQuery;

export const selectAllUsersQuery = () => {
  return ResultAsync.fromPromise(
    db.select().from(usersTable),
    (e) => new DbClientError("データベース接続確立エラー", { cause: e }),
  ).andThen((userDataModels) => Result.combine(userDataModels.map(toModel)));
};
export type SelectAllUsersQuery = typeof selectAllUsersQuery;

export const selectUserByNameQuery = (name: UserName) => {
  return ResultAsync.fromPromise(
    db.select().from(usersTable).where(eq(usersTable.name, name)),
    (e) => new DbClientError("データベース接続確立エラー", { cause: e }),
  ).andThen((userDataModels) =>
    userDataModels.length ? toModel(userDataModels[0]) : ok(undefined),
  );
};
export type SelectUserByNameQuery = typeof selectUserByNameQuery;
```

### ドメインサービス

- 値オブジェクトやエンティティに記述すると不自然なふるまいを定義する
- インフラストラクチャが絡む場合はリポジトリを高階関数としてDIする

```typescript
import type { SelectUserByNameQuery } from "../../../infrastructure/user";
import type { User } from "../model";

export const userExists =
  (selectUserByNameQuery: SelectUserByNameQuery) => (user: User) => {
    return selectUserByNameQuery(user.name).map(
      (duplicateUser) => duplicateUser !== undefined,
    );
  };
export type UserExists = ReturnType<typeof userExists>;
```

### ユースケース

- ドメインオブジェクトを組み合わせて実行する
- リポジトリや部分適用されたドメインサービスを高階関数として使用する順番にDIする

```typescript
import { err } from "neverthrow";
import { v7 as uuidv7 } from "uuid";
import { User } from "../../domain/user/model/user";
import type { UserExists } from "../../domain/user/service/check-user-exists";
import type { InsertUserCommand } from "../../infrastructure/user";
import { CanNotRegisterUserError } from "./errors";

export const registerUser =
  (userExists: UserExists, insertUserCommand: InsertUserCommand) =>
  async (name: string) => {
    // ユーザーの生成
    const userResult = User(uuidv7(), name);
    if (userResult.isErr()) return err(userResult.error);

    // ユーザーの重複確認
    const existsResult = await userExists(userResult.value);
    if (existsResult.isErr()) return err(existsResult.error);
    if (existsResult.value)
      return err(new CanNotRegisterUserError("ユーザーは既に存在しています。"));

    // ユーザーの作成
    return await insertUserCommand(userResult.value);
  };
```

```typescript
import { err } from "neverthrow";
import { UserId, UserName } from "../../domain/user/model";
import { changeUserName } from "../../domain/user/model/user";
import type { UserExists } from "../../domain/user/service/check-user-exists";
import type {
  SelectUserByIdQuery,
  UpdateUserCommand,
} from "../../infrastructure/user";
import { CanNotRegisterUserError, UserNotFoundError } from "./errors";

export const updateUserName =
  (
    selectUserByIdQuery: SelectUserByIdQuery,
    userExists: UserExists,
    updateUserCommand: UpdateUserCommand,
  ) =>
  async (id: string, name: string) => {
    // ユーザーIDのバリデーション
    const userIdResult = UserId(id);
    if (userIdResult.isErr()) return err(userIdResult.error);

    // ユーザーの存在確認
    const userResult = await selectUserByIdQuery(userIdResult.value);
    if (userResult.isErr()) return err(userResult.error);
    const user = userResult.value;
    if (user === undefined)
      return err(new UserNotFoundError("ユーザーが見つかりませんでした。"));

    // ユーザー名のバリデーション
    const userNameResult = UserName(name);
    if (userNameResult.isErr()) return err(userNameResult.error);

    // ユーザー名の変更
    const updatedUser = changeUserName(user, userNameResult.value);

    // ユーザーの重複確認
    const existsResult = await userExists(updatedUser);
    if (existsResult.isErr()) return err(existsResult.error);
    if (existsResult.value)
      return err(new CanNotRegisterUserError("ユーザーは既に存在しています。"));

    // ユーザー名の更新
    return await updateUserCommand(updatedUser);
  };
```

### 使用例

```typescript
import { userExists } from "./packages/domain/user/service/check-user-exists";
import {
  insertUserCommand,
  selectAllUsersQuery,
  selectUserByNameQuery,
} from "./packages/infrastructure/user";
import { getAllUsers } from "./packages/use-case/user/get-all-users";
import { registerUser } from "./packages/use-case/user/register-user";

const main = async () => {
  await registerUser(
    userExists(selectUserByNameQuery),
    insertUserCommand,
  )("hoge").then((result) => {
    result.match(
      (value) => console.log(value),
      (error) => console.error(error),
    );
  });

  await getAllUsers(selectAllUsersQuery)().then((result) => {
    result.match(
      (value) => console.log(value),
      (error) => console.error(error),
    );
  });

  // await updateUserName(
  //   selectUserByIdQuery,
  //   userExists(selectUserByNameQuery),
  //   updateUserCommand,
  // )("01966230-8abb-71ca-80f2-0f127a1c4cf0", "fuga").then((result) => {
  //   result.match(
  //     (value) => console.log(value),
  //     (error) => console.error(error),
  //   );
  // });

  // await deleteUser(
  //   selectUserByIdQuery,
  //   deleteUserCommand,
  // )("01966230-8abb-71ca-80f2-0f127a1c4cf0").then((result) => {
  //   result.match(
  //     (value) => console.log(value),
  //     (error) => console.error(error),
  //   );
  // });
};

main();
```
